# -*- coding: utf-8 -*-
"""HMM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16hdkhjxuvA0IE35OC_Aloix9QxurjQcR
"""

import numpy as np
from math import log
import time
import copy

# EXPERIEMTNs:
# Turn chords into PSA and sample from that rather than a MC
#
# obs1 = ['c', 'd', 'e', 'c', 'd', 'c', 'd', 'e', 'c', 'd']
# obs2 = ['d', 'e', 'd', 'e', 'c', 'd', 'c', 'd', 'e', 'c']
# hidden_obs1 = ['I', 'I', 'I', 'V', 'V', 'V', 'I', 'I', 'V', 'V']
# hidden_obs2 = ['I', 'I', 'I', 'I', 'V', 'V', 'V', 'V', 'I', 'I']
#
# hidden_obs = [obs1, obs2]
# obs = [hidden_obs1, hidden_obs2]


class HMM:
    def __init__(self, obs_sequences, hidden_obs_sequences):
        self.alphabet = set()
        self.hidden_alphabet = set()
        for obs_sequence, hidden_obs_sequence in zip(obs_sequences, hidden_obs_sequences):
            self.alphabet = self.alphabet.union(set(obs_sequence))
            self.hidden_alphabet = self.hidden_alphabet.union(set(hidden_obs_sequence))
        self.alphabet = sorted(list(self.alphabet))
        self.hidden_alphabet = sorted(list(self.hidden_alphabet))
        print('Num Notes before everything: ', len(self.hidden_alphabet), self.hidden_alphabet[0:3])
        print('Num Chords before everything: ', len(self.alphabet), self.alphabet[0:3])

    def create_hmm(self, obs_sequences, hidden_obs_sequences):
        hmm = dict()  # Create a dictionary
        # Match each note with a chord
        for obs_sequence, hidden_obs_sequence in zip(obs_sequences, hidden_obs_sequences):  # For each note, chord pair
            # print('obs seq')
            # print(obs_sequence)
            # print('hidden obs seq')
            # print(hidden_obs_sequence)
            obs_sequence = np.insert(obs_sequence, 0, '')
            hidden_obs_sequence = np.insert(hidden_obs_sequence, 0, '')

            # Match every song of notes with every song of chords
            for obs, hidden_obs in zip(obs_sequence, hidden_obs_sequence):  # For each song
                if hidden_obs == '':
                    state = "[]"
                    next_state = "[]"
                else:
                    state = str([hidden_obs])  # Create tuple of a note and a chord
                    next_state = str([obs])
                if state not in hmm:  # Check if the tuple is not in hmm
                    hmm[state] = dict()  # Add tuple to hmm with count of 0
                if next_state not in hmm[state]:
                    hmm[state][next_state] = 0  # Increment the count of that tuple
                hmm[state][next_state] += 1  # Increment the count of that tuple

        for h_alpha in self.hidden_alphabet:  # For each note in first song
            state = str([h_alpha])
            sum = 0  # Counting something
            for alpha in self.alphabet:  # For each chord in first song
                next_state = str([alpha])
                if state in hmm:  # Check if note, chord pair is in hmm which I think is always true
                    if next_state in hmm[state]:
                        sum += hmm[state][next_state]  # Aggregate the count for that key
            for alpha in self.alphabet:  # For each chord in first song
                next_state = str([alpha])
                if state in hmm:  # Check if note, chord pair is in hmm which I think is always true
                    if next_state in hmm[state]:
                        hmm[state][next_state] = float(hmm[state][next_state]) / sum  # Take the average
        return hmm


class MM:
    def __init__(self, obs_sequences):
        self.alphabet = set()
        for obs_sequence in obs_sequences:
            self.alphabet = self.alphabet.union(set(obs_sequence))
        self.alphabet = sorted(list(self.alphabet))

    def create_mm(self, obs_sequences):
        mm = dict()
        for obs_sequence in obs_sequences:
            for i in range(len(obs_sequence) - 1):
                if i == 0:
                    state = "[]"
                    next_state = str([obs_sequence[i + 1]])
                else:
                    state = str([obs_sequence[i]])
                    next_state = str([obs_sequence[i + 1]])
                if state not in mm:
                    mm[state] = dict()
                if next_state not in mm[state]:
                    mm[state][next_state] = 0
                mm[state][next_state] += 1

        modified_alphabet = copy.deepcopy(self.alphabet)
        modified_alphabet.append("[]")
        for alpha in modified_alphabet:  # For each note in first song
            state = str([alpha])
            if alpha == "[]":
                state = "[]"
            sum = 0  # Counting something
            for other_alpha in self.alphabet:  # For each chord in first song
                next_state = str([other_alpha])
                if state in mm:  # Check if note, chord pair is in hmm which I think is always true
                    if next_state in mm[state]:
                        sum += mm[state][next_state]  # Aggregate the count for that key
            for other_alpha in self.alphabet:  # For each chord in first song
                next_state = str([other_alpha])
                if state in mm:  # Check if note, chord pair is in hmm which I think is always true
                    if next_state in mm[state]:
                        mm[state][next_state] = float(mm[state][next_state]) / sum  # Take the average
        return mm


class PredictionSuffixCommon:
    def __init__(self, data=None):
        if data is None:
            self.data = {}
        else:
            self.data = data

    def get_parent(self, state_string):
        if (len(eval(state_string)) > 1):  # Check if state has more than 1 letter in it
            parent = self.get_suffixes(state_string)[-1]  # Parent is the longest suffix
            while str(parent) not in self.data:  # Check if the parent is not in the data
                parent = self.get_parent(parent)  # Get a shorter suffix
        else:  # If the string has one or zero letters
            parent = []  # The parent is lambda
        return parent

    def get_suffixes(self, state_string):
        suffixes = []
        state = eval(state_string)  # state is a string
        for index in range(len(state) - 1):
            suffixes.append(str(state[-1 * index - 1:]))
        return suffixes

    def add_suffixes(self):
        new_data = copy.deepcopy(self.data)
        for state in self.data.keys():
            for suffix in self.get_suffixes(state):
                if (suffix not in new_data):
                    parent = self.get_parent(suffix)
                    new_data[suffix] = new_data[parent]
        self.data = new_data

    def get_prefixes(self, state_string):
        prefixes = []
        state = eval(state_string)
        for index in range(1, len(state)):
            prefixes.append(str(state[0:index]))
        return prefixes

    def add_prefixes(self):
        new_data = copy.deepcopy(self.data)
        for state_string in self.data.keys():
            for prefix in self.get_prefixes(state_string):
                if prefix not in new_data:
                    parent = self.get_parent(prefix)
                    new_data[prefix] = new_data[parent]
        self.data = new_data


class PST(PredictionSuffixCommon):
    def __init__(self, obs_sequences):
        PredictionSuffixCommon.__init__(self)
        self.alphabet = set()
        self.state_count = dict()
        self.data = dict()
        for obs_sequence in obs_sequences:
            self.alphabet = self.alphabet.union(set(obs_sequence))
        self.alphabet = sorted(list(self.alphabet))
        print('Chords before everything: ', len(self.alphabet))

        self.number_of_obs_sequences = len(obs_sequences)
        self.number_of_notes = 0
        for obs_sequence in obs_sequences:
            self.number_of_notes += len(obs_sequence)

        self.approximation = 1.0
        self.alphabet_size = len(self.alphabet)
        self.max_state_size = 3  # Defines size of the mixed order, basically k
        self.max_states = 2

        self.smoothing_factor = self.approximation / (
                    48 * self.max_state_size * self.alphabet_size)  # 0.1 / (48 * 3 * 3) = 0
        self.minimum_empirical_string_probability = self.approximation / (
                    2 * self.max_states * self.max_state_size * log(1 / self.smoothing_factor)) - (
                                                                self.alphabet_size / (8 * self.max_states))  # 0
        self.minimum_empirical_next_symbol_probability = (
                                                                     1 + self.smoothing_factor * self.alphabet_size) * self.smoothing_factor  # 0
        self.minimum_empirical_next_symbol_probability_ratio = 1 + 3 * self.smoothing_factor * self.alphabet_size  # 1

        for obs_sequence in obs_sequences:
            self.state_counter(obs_sequence)

    def state_counter(self, obs_sequence):  # Oscillating Sliding Window
        for i in range(1, self.max_state_size + 2):
            for j in range(0, len(obs_sequence) + 1 - i):
                state = str(obs_sequence[j:j + i])
                if state not in self.state_count:
                    self.state_count[state] = 0
                self.state_count[state] += 1

    def get_transition_occurance(self, state, transition):
        if transition == '*':  # i.e. Any transition
            occurance = 0
            for transition in self.alphabet:
                next_state = str(state + [transition])
                if next_state in self.state_count:
                    occurance += self.state_count[next_state]
            return occurance
        else:
            next_state = str(state + [transition])
            if next_state in self.state_count:
                return self.state_count[next_state]
        return 0

    def get_transition_probability(self, state, transition):
        all_transitions_occurance = self.get_transition_occurance(state, '*')
        if all_transitions_occurance != 0:
            return self.get_transition_occurance(state, transition) / all_transitions_occurance
        return all_transitions_occurance

    def parent_child_transition_ratio(self, state, parent, transition):
        transition_probability = self.get_transition_probability(state, transition)
        if transition_probability >= self.minimum_empirical_next_symbol_probability:  # > 0
            parent_transition_probability = self.get_transition_probability(parent, transition)
            return transition_probability / parent_transition_probability
        else:
            return 0.

    def add_parents_to_frontier(self, state, states, frontier):
        for i in range(1, len(state)):  # Grab all suffixes "parents"
            parent = state[i:]  # Grab suffix "parent/grandparent" of candidate state
            if parent not in states:
                frontier.append(parent)

    def add_children_to_frontier(self, state, states, frontier):
        if len(state) < self.max_state_size:
            for transition in self.alphabet:
                next_state = [
                                 transition] + state  # Is this actually a next state given that it is added at the beginning
                # if self.empirical_string_probability(new_string) >= self.minimum_empirical_string_probability:
                # if self.get_transition_occurance(next_state, '*') / (self.number_of_notes - self.number_of_obs_sequences):
                if self.get_transition_occurance(next_state, '*') > 0:
                    if (next_state not in states) and (next_state not in frontier):
                        frontier.append(next_state)

    def create_pst(self, obs_sequences):
        states = []
        states.append([])
        # frontier = [[letter]] for letter in self.alphabet if self.empirical_string_probability([letter]) >= self.minimum_empirical_string_probability
        frontier = [[transition] for transition in self.alphabet]
        while len(frontier) > 0:
            candidate_state = frontier.pop()
            parent = candidate_state[1:]  # Grab suffix "parent" of candidate state

            find = False
            alphabet_index = 0
            while ((not find) and (alphabet_index < self.alphabet_size)):
                transition = self.alphabet[alphabet_index]
                transition_ratio = self.parent_child_transition_ratio(candidate_state, parent, transition)
                if transition_ratio >= self.minimum_empirical_next_symbol_probability_ratio:  # 1
                    find = True
                    states.append(candidate_state)
                    self.add_parents_to_frontier(candidate_state, states, frontier)
                alphabet_index += 1
            self.add_children_to_frontier(candidate_state, states, frontier)

        self.determine_all_state_transitions(states)
        self.add_suffixes()
        self.add_prefixes()

    # We hand in the states selected for the pst and determine all of the transition probabilities the states have
    def determine_all_state_transitions(self, states):
        for state in states:
            self.data[str(state)] = dict()
            for transition in self.alphabet:
                transition_probability = self.get_transition_probability(state, transition)
                if transition_probability > 0:  # If the state can actually have this transition
                    self.data[str(state)][transition] = transition_probability


class PSA(PredictionSuffixCommon):
    def __init__(self, data):
        # Initialize PredictionSuffixCommon
        PredictionSuffixCommon.__init__(self, data)

    def create_momm(self):
        momm = dict()
        for state, transitions in self.data.items():
            state = eval(state)  # turn str(state) into actual list(state)
            momm[str(state)] = dict()
            # Converts state->transition probabilities to state->state probabilities
            for transition, probability in transitions.items():
                next_state = state + [transition]
                if str(next_state) not in self.data:
                    next_state = self.get_parent(str(next_state))
                momm[str(state)][str(next_state)] = probability
        return momm


class Data:
    # location of .nyp file
    def __init__(self):
        self.file = "/home/kane0058/Downloads/song_list.npy"
        self.threshold = 20

    # returns a 2D array of a list song's pitches
    def thresh(self, list):
        allowed = []
        for pitches in list:
            if len(pitches) > self.threshold:
                allowed.append(pitches)
        return allowed

    def get_pitches(self):
        list = np.load(self.file)
        return self.thresh(list[0])

    # returns a 2D array of a list song's chords
    def get_chords(self):
        list = np.load(self.file)
        return self.thresh(list[1])


class NotePredictor:
    def __init__(self, momm, hmm, alphabet):

        #print(momm)
        #print(hmm)
        #print('alpah', alphabet)

        self.alphabet = alphabet
        self.hidden_alphabet = [x for x in momm]

        self.t_k = dict()
        self.e_k = dict()

        for i, state in enumerate(momm):
            self.t_k[state] = i

        del hmm['[]']

        for i in range(0, len(self.alphabet)):
            self.e_k[str([self.alphabet[i]])] = i

        print('Num States: ', len(self.hidden_alphabet))
        print('Num Chords: ', len(self.e_k))

        self.transition_probabilities = np.zeros((len(self.hidden_alphabet), len(self.hidden_alphabet)))
        self.emission_probabilities = np.zeros((len(self.hidden_alphabet), len(self.e_k)))

        for state, transitions in momm.items():
            for next_state, probability in transitions.items():
                self.transition_probabilities[self.t_k[state]][self.t_k[next_state]] = probability
            e_state = ''
            if state != '[]':
                e_state = str([eval(state)[-1]])

            if e_state in hmm:
                for chord, chord_probability in hmm[e_state].items():
                    # print(e_state, state, self.t_k[state], chord, self.e_k[chord], chord_probability, hmm[e_state])
                    self.emission_probabilities[self.t_k[state]][self.e_k[chord]] = chord_probability

    def p(self):
        for k, v in self.t_k.items():
            print(k, v)
        print(self.e_k)
        print(self.transition_probabilities)
        print(self.emission_probabilities)

    def get_distribution(self, arr):
        distribution = []
        arr_sum = np.sum(arr)
        if arr_sum == 0:
            return arr
        for element in arr:
            distribution.append(element / arr_sum)
        return distribution

    def get_note(self, note_distribution):
        note_index = np.random.choice(len(note_distribution), 1, p=note_distribution)[0]
        for note in self.t_k:
            if self.t_k[note] == note_index:
                return note, note_index

    def get_backward_notes(self, forward_probabilities):
        notes = []
        note_index = None
        # for index in reversed(range(1,len(forward_probabilities)))
        for prev_state_probabilities in reversed(forward_probabilities):
            prev_state_distribution = None
            if note_index is None:
                prev_state_distribution = prev_state_probabilities
            else:
                prev_state_distribution = prev_state_probabilities[note_index]
            note, note_index = self.get_note(prev_state_distribution)
            notes.append(note)
        return reversed(notes)

    def get_notes(self, obs_sequence):
        distributions = self.forward(obs_sequence, '[]')
        if distributions is not None:
            #print('distributions\n')
            #for dis in distributions[-1]:
            #    print(dis)
            return self.get_backward_notes(distributions)

    def forward(self, obs_sequence, start_state):
        distributions = []
        state_probabilities = self.transition_probabilities[self.t_k[start_state]] * self.emission_probabilities[:,
                                                                                     self.e_k[obs_sequence[0]]]
        for i in range(1, len(obs_sequence)):
            prev_state_probabilities = []
            prev_state_distributions = []
            for col in range(len(self.transition_probabilities)):
                prev_state_probability = state_probabilities * self.transition_probabilities[:, col]
                prev_state_probabilities.append(prev_state_probability)
                prev_state_distributions.append(self.get_distribution(prev_state_probability))
            distributions.append(prev_state_distributions)

            state_probabilities = np.sum(prev_state_probabilities, axis=1) * self.emission_probabilities[:,
                                                                             self.e_k[obs_sequence[i]]]
        if sum(self.get_distribution(state_probabilities)) == 0:
            return None
        distributions.append(self.get_distribution(state_probabilities))

        # print(state_probabilities)
        return distributions


class MichaelBarrowAndTheTourists:
    def __init__(self, chords, notes, chords_w_notes):
        hmm = HMM(chords_w_notes[0], chords_w_notes[1])
        self.hmm = hmm.create_hmm(chords_w_notes[0], chords_w_notes[1])
        print('Created HMM')
        pst = PST(notes)
        pst.create_pst(notes)
        print('Created PST')
        psa = PSA(pst.data)
        self.momm = psa.create_momm()
        print('Created MOMM')
        mm = MM(chords)
        self.mm = mm.create_mm(chords)  # TODO: Add a beginning null state
        print('Created MM')
        self.start_state = '[]'

        self.alphabet = set()
        self.hidden_alphabet = set()
        for obs_sequence in chords:
            self.alphabet = self.alphabet.union(set(obs_sequence))
        for hidden_obs_sequence in notes:
            self.hidden_alphabet = self.hidden_alphabet.union(set(hidden_obs_sequence))
        self.alphabet = sorted(list(self.alphabet))
        self.hidden_alphabet = sorted(list(self.hidden_alphabet))

        self.transition_prob_keys = dict()
        self.emission_prob_keys = dict()

        self.n = NotePredictor(self.momm, self.hmm, self.alphabet)
        print('Created NotePredictor')
        # self.n.p()

    def clean_notes(self, states):
        notes = []
        for state in states:
            notes.append(str(eval(state)[-1]))
        return notes

    def generate_music(self, song_length):
        # Get chords from Markov Chain
        tries = 10
        for _ in range(tries):
            chords = self.get_chords(song_length)
            possible_notes = self.n.get_notes(chords)
            if possible_notes is not None:
                return self.clean_notes(possible_notes), self.clean_notes(chords)

    def traverse_mm(self, mm, state):
        transitions = mm[state]
        next_states = []
        probabilities = []
        for next_state, probability in transitions.items():
            next_states.append(next_state)
            probabilities.append(probability)
        index = np.random.choice(len(next_states), 1, p=probabilities)[0]
        return next_states[index]

    def get_chords(self, song_length):
        # Return a list of chords
        chords = []
        state = copy.deepcopy(self.start_state)
        for i in range(int(song_length/4)):
            state = self.traverse_mm(self.mm, state)
            chords.append(state)
            chords.append(state)
            chords.append(state)
            chords.append(state)
        return chords

    def normalize_probs(self, probs):
        probs_sum = sum(probs)
        for i in range(len(probs)):
            probs[i] = probs[i] / probs_sum
        return probs


#   def get_note(self, chord, prev_state): # THIS MIGHT BE BROKEN BECAUSE I FIXED HMM
#     print('Chord and prev state', chord, prev_state)
#     states = []
#     probs = []
#     state_note_probabilities = self.momm[prev_state]
#     chord_note_probabilities = self.hmm[chord]
#     for chord_note, hidden_probability in chord_note_probabilities.items():
#       for state_note, transition_probability in state_note_probabilities.items():
#         print(chord_note, hidden_probability, state_note, transition_probability)
#         if eval(state_note)[-1] == eval(chord_note)[0]:
#           states.append((chord_note, state_note))
#           probs.append(hidden_probability*transition_probability)
#     probs = self.normalize_probs(probs)
#     print(probs, states)
#     index = np.random.choice(len(probs), 1, p=probs)[0]
#     return states[index]


if __name__=='__main__':
    data = Data()
    obs = data.get_chords()[-5:]
    print(obs[0][:20])
    hidden_obs = data.get_pitches()[-5:]
    print(hidden_obs[0][:20])
    start = time.time()
    # print(len(obs), len(hidden_obs))
    # s = 0
    # for o in obs:
    #     s += len(o)
    # print(s)
    # print(s/len(obs)*(3/10))

    m = MichaelBarrowAndTheTourists(obs, hidden_obs, (obs, hidden_obs))
    for _ in range(5):
        notes, chords = m.generate_music(20)
        print('\n Notes:')
        print(notes)
        print('Chords:')
        print(chords)
    print(time.time() - start)
    # # print(m.generate_music()) # TODO: doesn't always work because chord 'V' doesn't transition to note 'e'. So we need edge case
















